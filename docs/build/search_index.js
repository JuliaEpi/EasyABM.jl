var documenterSearchIndex = {"docs":
[{"location":"predator_prey/#Predator-prey-model","page":"Predator-prey","title":"Predator-prey model","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"using EasyABM","category":"page"},{"location":"predator_prey/#Step-1:-Create-Agents-and-Model","page":"Predator-prey","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"We create 200 agents all of type sheep to begin with. Our model parameters are ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"max_energy : The maximum energy that an agent (sheep or wolf) can have. \nwolfbirthrate : Probabality of a wolf agent to reproduce once its energy is greater than max_energy/2.  \nsheepbirthrate : Probabality of a wolf agent to reproduce once its energy is greater than max_energy/2. \nwolveskillability : The probability of a wolf to kill a neighboring sheep.\ngrassgrowprob : The probability of one unit of grass growing on a patch at a given timestep.\nmax_grass : Max grass a patch can have.\ninitialwolfpercent : The percent of agents which are wolf initially. ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"@enum agenttype sheep wolf\nagents = create_2d_agents(200, pos = (1,1), color = :white, atype = sheep, \n    energy = 10.0, keeps_record_of=[:pos, :energy ])\nmodel = create_2d_model(agents, grid_size = (20,20), \n    max_energy = 50, \n    wolf_birth_rate = 0.01,\n    sheep_birth_rate = 0.1,\n    wolves_kill_ability = 0.2,\n    max_grass = 5,\n    initial_wolf_percent = 0.2,\n    grass_grow_prob = 0.2,\n    periodic = true)","category":"page"},{"location":"predator_prey/#Step-2:-Initialise-the-model","page":"Predator-prey","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"In the second step we initialise the agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we randomly set amount of grass and accordingly color at each patch. We also set a fraction initial_wolf_percent of agents to be of type wolf. We set color of sheeps to white and that of wolves to black. We also randomly set the energy and positions of agents. In the init_model! function through argument props_to_record we tell EasyABM to record the color property of patches during model run. ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"function initialiser!(model)\n    max_grass = model.parameters.max_grass\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            grass = rand(1:max_grass)\n            model.patches[i,j].grass = grass\n            hf = Int(ceil(max_grass/2))\n            model.patches[i,j].color = grass > hf ? :green : (grass > 0 ? :blue : :grey)\n        end\n    end\n    for agent in model.agents\n        if rand()< model.parameters.initial_wolf_percent \n            agent.atype = wolf\n            agent.color = :black\n        else\n            agent.atype = sheep\n            agent.color = :white\n        end\n        agent.energy = rand(1:model.parameters.max_energy)+0.0\n        agent.pos = (rand(1:model.size[1])-0.5, rand(1:model.size[2])-0.5)\n    end\n            \nend\n\ninit_model!(model, initialiser = initialiser!, props_to_record = Dict(\"patches\"=>[:color]))","category":"page"},{"location":"predator_prey/#Step-3:-Run-the-model","page":"Predator-prey","title":"Step 3: Run the model","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"In this step we implement the step logic of the predator prey model in the step_rule! function and run the model for 100 steps. ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"function change_pos!(agent)\n    dx = rand(-1:1)\n    dy = rand(-1:1)\n    agent.pos += (dx, dy)\nend\n\nfunction reproduce!(agent, model)\n    new_agent = create_similar(agent)\n    agent.energy = agent.energy/2\n    new_agent.energy = agent.energy\n    add_agent!(new_agent, model)\nend\n\nfunction eat_sheep!(wolf, sheep, model)\n    kill_agent!(sheep, model) \n    wolf.energy+=1\nend\n\n\nfunction act_asa_wolf!(agent, model)\n    if !(is_alive(agent))\n        return\n    end\n    energy = agent.energy\n    if energy > 0.5*model.parameters.max_energy\n        if rand()<model.parameters.wolf_birth_rate\n            reproduce!(agent, model)\n        end\n    elseif energy > 0 \n        nbrs = neighbors(agent, model, 1, metric = :grid)\n        n = length(nbrs)\n        if n>0\n            nbr = nbrs[rand(1:n)]\n            if (nbr.atype == sheep)&&(is_alive(nbr))\n                ability = model.parameters.wolves_kill_ability\n                (rand()<ability)&&(eat_sheep!(agent, nbr, model))\n            end\n        end\n        change_pos!(agent)\n    else\n        kill_agent!(agent, model)\n    end\nend\n\nfunction act_asa_sheep!(agent, model)\n    if !(is_alive(agent))\n        return\n    end\n    energy = agent.energy\n    if energy >0.5* model.parameters.max_energy\n        if rand()<model.parameters.sheep_birth_rate\n            reproduce!(agent, model)\n        end\n        change_pos!(agent)\n    elseif energy > 0 \n        patch = get_grid_loc(agent, model)\n        grass = model.patches[patch...].grass\n        if grass>0\n            model.patches[patch...].grass-=1\n            agent.energy +=1\n        end\n        change_pos!(agent)\n    else\n        kill_agent!(agent, model)\n    end\nend\n\n\n\nfunction step_rule!(model)\n    if model.max_id>800 # use some upper bound on max agents to avoid system hang\n        return\n    end\n    for agent in model.agents\n        if agent.atype == wolf\n            act_asa_wolf!(agent,model)\n        end\n        if agent.atype == sheep\n            act_asa_sheep!(agent, model)\n        end\n    end\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            patch = model.patches[i,j]\n            grass = patch.grass\n            max_grass = model.parameters.max_grass \n            if grass < max_grass\n                if rand()<model.parameters.grass_grow_prob\n                    patch.grass+=1\n                    hf = Int(ceil(max_grass/2))\n                    patch.color = grass > hf ? :green : (grass > 0 ? :yellow : :grey)\n                end\n            end\n        end\n    end\nend\n\nrun_model!(model, steps=100, step_rule = step_rule! )","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"animate_sim(model, show_grid=true)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"(Image: png)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"Once the model has been run it can be saved to the disk as a jld2 file using following function.","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"save_model(model, model_name = \"predator_prey_model\", save_as = \"predator_prey.jld2\", folder = \"/path/to/folder/\")","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"A model saved previously as jld2 file, can be fetched as follows ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"model = open_saved_model(model_name = \"predator_prey_model\", path = \"/path/to/folder/predator_prey.jld2\")","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[\n        (:wolf_birth_rate, :s, 0:0.01:1.0),\n        (:sheep_birth_rate, :s, 0.01:0.01:1.0),\n        (:initial_wolf_percent, :s, 0.01:0.01:0.9),\n        (:wolves_kill_ability, :s, 0.01:0.01:1.0),\n        (:grass_grow_prob, :s, 0.01:0.01:0.5)\n        ], \n    agent_plots=Dict(\"sheep\"=> agent-> agent.atype == sheep ? 1 : 0, \n        \"wolf\"=> agent-> agent.atype == wolf ? 1 : 0),\n    frames=200, show_grid=true)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"(Image: png)","category":"page"},{"location":"predator_prey/#Step-4:-Fetch-Data","page":"Predator-prey","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"We can fetch the number of wolves and sheeps at each time step as follows. ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"df = get_nums_agents(model, agent-> agent.atype == sheep, \n    agent->agent.atype == wolf, labels=[\"Sheep\", \"Wolf\"], \n    plot_result = true)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"(Image: png)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"schelling/#Schelling-segregation-model","page":"Schellings Segregation model","title":"Schelling segregation model","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"using EasyABM","category":"page"},{"location":"schelling/#Step-1:-Create-Agents-and-Model","page":"Schellings Segregation model","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"Lets create 200 agents with properties pos, mood and color. The keeps_record_of argument is list of properties that the agent will record during time evolution. The min_alike property of the model which specifies the minimum number of alike neighbors for an agent to be happy, is set to be 4. ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"@enum agentsfeeling happy sad\nagents = create_2d_agents(200, pos = (1,1), color = :green, mood = happy, keeps_record_of=[:pos, :mood])\nmodel = create_2d_model(agents, grid_size = (20,20), min_alike = 4)","category":"page"},{"location":"schelling/#Step-2:-Initialise-the-model","page":"Schellings Segregation model","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"In the second step we initialise the agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we randomly set agents color to be either :red or :green and set their positions randomly such that there is not more than one agent on each patch. Then we set the mood property of each agent to be happy or sad depending upon the number of alike agents in neighborhood. ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"function initialiser!(model)\n    min_alike = model.parameters.min_alike\n    for agent in model.agents\n        agent.color = [:red, :green][rand(1:2)]\n        x,y = random_empty_patch(model)   \n        agent.pos = (x-0.5,y-0.5)\n    end    \n    for agent in model.agents\n        nbrs = neighbors(agent, model, 1, metric = :grid)\n        num_alike = 0\n        for nbr in nbrs\n            if nbr.color == agent.color\n                num_alike += 1\n            end\n        end\n        if num_alike < min_alike\n            agent.mood = sad\n        end\n    end\nend\n\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"schelling/#Step-3:-Run-the-model","page":"Schellings Segregation model","title":"Step 3: Run the model","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"In this step we implement the step logic of the Schellings model in the step_rule! function and run the model for 200 steps. ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"function step_rule!(model)\n    min_alike = model.parameters.min_alike\n    for agent in model.agents\n        count_alike = 0\n        for nbr in neighbors(agent, model,1)\n            if agent.color == nbr.color\n                count_alike += 1\n            end\n        end\n        if count_alike ≥ min_alike\n            agent.mood = happy\n        else\n            agent.mood = sad\n            x,y = random_empty_patch(model) \n            agent.pos = (x-0.5,y-0.5)\n        end\n    end\n    return\nend\n\nrun_model!(model, steps=200, step_rule = step_rule! )","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"animate_sim(model, show_grid=true)","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"(Image: png)","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"Once the model has been run it can be saved to the disk as a jld2 file using following function.","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"save_model(model, model_name = \"schelling_model\", save_as = \"schelling.jld2\", folder = \"/path/to/folder/\")","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"A model saved previously as jld2 file, can be fetched as follows ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"model = open_saved_model(model_name = \"schelling_model\", path = \"/path/to/folder/schelling.jld2\")","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"create_interactive_app(model, initialiser= initialise!,\n    step_rule=step_rule!,\n    model_controls=[(:min_alike, :s, 1:8)], \n    agent_plots=Dict(\"happy\"=> agent-> agent.mood == happy ? 1 : 0, \"sad\"=> agent-> agent.mood == sad ? 1 : 0),\n    frames=200) ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"(Image: png)","category":"page"},{"location":"schelling/#Step-4:-Fetch-Data","page":"Schellings Segregation model","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"In this step we fetch data of number of happy and sad agents at each time step as a dataframe using following line of code. ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"df = get_nums_agents(model, agent-> agent.mood == happy, agent-> agent.mood == sad,labels=[\"happy\",\"sad\"], plot_result=true)","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"(Image: png)","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"SIR/#SIR-model","page":"SIR model","title":"SIR model","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In the agent-based modeling approach an epidemiological model, like SIR model can have a large number of parameters depending upon the requirements. Below we will implement a basic SIR model in EasyABM.","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"using EasyABM","category":"page"},{"location":"SIR/#Step-1:-Create-Agents-and-Model","page":"SIR model","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In our SIR model there will be four type of agents - agentS (susceptible), agentI (infectious), agentR (recovered) and agentD (dead). We assume that the recovered agents become immune and do not get infected again. We create 500 2d agents all of type agentS (later in the initilisation step will set the type of some agents to be agentI). The not_well_since property of an agent is the time since the agent got infected. Our model has parameters initially_sick (number of agents initially sick), sickness_duration (duration of sickness), infection_prob (probability of infection when an infected agent comes in contact with a susceptible agent) and death_prob (the probability of death from infection). ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"\n@enum AgentType begin\n    agentS=1\n    agentI=2\n    agentR=3\n    agentD=4\nend\n\nagents = create_2d_agents(500, color=:green, \n        atype = agentS, not_well_since = 0, \n        keeps_record_of = [:atype, :color, :pos]);\n\nmodel = create_2d_model(agents, grid_size=(50,50), \n        periodic = true, initially_sick = 10, \n        sickness_duration = 21, infection_prob = 0.8, \n        death_prob=0.05);","category":"page"},{"location":"SIR/#Step-2:-Initialise-the-model","page":"SIR model","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In the second step we initialise the agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we set first initially_sick number of agents to be of type agentI and set their color to :red. All other agents are set to be of type agentS with color :green. We also set each agents position at the center of a randomly selected patch.  ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"function initialiser!(model)\n    for (i,agent) in enumerate(model.agents)\n        if i<=model.parameters.initially_sick\n            agent.atype = agentI\n            agent.color = :red\n        else \n            agent.atype = agentS\n            agent.color = :green\n        end\n        agent.not_well_since = 0 \n        x = rand(1:model.size[1])\n        y = rand(1:model.size[2])\n        agent.pos = (x-0.5, y-0.5) # center of a random patch\n    end\nend\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"SIR/#Step-3:-Run-the-model","page":"SIR model","title":"Step 3: Run the model","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In this step we implement the step logic of the SIR model in the step_rule! function and run the model for 100 steps. ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"function die_or_recover(agent, death_prob)\n    if rand()<death_prob\n        agent.atype = agentD\n        agent.color = :black\n    else\n        agent.atype = agentR\n        agent.color = :yellow\n    end\n    agent.not_well_since = 0 \nend\n\nfunction infect_neighbors(agent, nbrs, infection_prob)\n    for nbr in nbrs\n        if (nbr.atype ==agentS) && (rand()< infection_prob)\n            nbr.atype = agentI\n            nbr.not_well_since = 0\n            nbr.color = :red\n        end\n    end\nend\n\nfunction change_position(agent)\n    dx =rand(-1:1)\n    dy =rand(-1:1)\n    agent.pos += (dx,dy)\nend\n\nfunction step_rule!(model)\n    parameters = model.parameters\n    for agent in model.agents\n        nbrs = neighbors(agent, model, 1, metric = :grid) #immediate neighbors on grid\n        if agent.atype == agentI\n             agent.not_well_since +=1\n            if agent.not_well_since > parameters.sickness_duration\n                die_or_recover(agent, parameters.death_prob)\n            elseif agent.not_well_since>1\n                infect_neighbors(agent, nbrs, parameters.infection_prob)\n            end   \n        end\n        if agent.atype !=agentD\n            change_position(agent)\n        end   \n    end\nend\n\n\nrun_model!(model, steps=100, step_rule = step_rule! )","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"animate_sim(model)","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"(Image: png)","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"Once the model has been run it can be saved to the disk as a jld2 file using following function.","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"save_model(model, model_name = \"sir_model\", save_as = \"sir.jld2\", folder = \"/path/to/folder/\")","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"A model saved previously as jld2 file, can be fetched as follows ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"model = open_saved_model(model_name = \"sir_model\", path = \"/path/to/folder/sir.jld2\")","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[(:initially_sick, :s, 1:500), \n        (:sickness_duration, :s, 5:25),\n        (:infection_prob, :s, 0.01:0.01:1.0),\n        (:death_prob, :s, 0.01:0.01:0.1)\n        ],\n    agent_plots = Dict(\"Susceptible\"=> ag -> ag.atype == agentS ? 1 : 0, \n        \"Infected\" => ag -> ag.atype == agentI ? 1 : 0,\n        \"Recovered\" => ag -> ag.atype == agentR ? 1 : 0\n        ),\n    frames=70)  ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"(Image: png)","category":"page"},{"location":"SIR/#Step-4:-Fetch-Data","page":"SIR model","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"The following line of code fetches data of average number of susceptible, infectious and recovered agents.  The function get_agents_avg_props averages over all agents the values returned by functions sent to it as arguments. ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"df = get_agents_avg_props(model, \n    ag -> ag.atype == agentS ? 1 : 0, # returns 1 if agent is of type agentS, else 0\n    ag -> ag.atype == agentI ? 1 : 0, # returns 1 if agent is of type agentI, else 0\n    ag -> ag.atype == agentR ? 1 : 0, # returns 1 if agent is of type agentR, else 0\n    labels = [\"Susceptible\", \"Infected\", \"Recovered\"],\n    plot_result = true\n)","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"(Image: png)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"EasyABM provides following functions for agent based simulations. ","category":"page"},{"location":"api/#Functions-for-creating-agents","page":"API","title":"Functions for creating agents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"create_2d_agent\ncreate_2d_agents\ncreate_3d_agent\ncreate_3d_agents\ncreate_graph_agent\ncreate_graph_agents\ncreate_similar","category":"page"},{"location":"api/#EasyABM.create_2d_agent","page":"API","title":"EasyABM.create_2d_agent","text":"create_2d_agent(; kwargs...) -> EasyABM.AgentDict2D{Symbol, Any}\n\n\nCreates a single 2d agent with properties specified as keyword arguments.  Following property names are reserved for some specific agent properties      - pos : position     - vel : velocity     - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keepsrecordof : list of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_2d_agents","page":"API","title":"EasyABM.create_2d_agents","text":"create_2d_agents(n::Int64; kwargs...) -> Vector{EasyABM.AgentDict2D{Symbol, Any}}\n\n\nCreates a list of n 2d agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_3d_agent","page":"API","title":"EasyABM.create_3d_agent","text":"create_3d_agent(; kwargs...) -> EasyABM.AgentDict3D{Symbol, Any}\n\n\nCreates a single 3d agent with properties specified as keyword arguments. Following property names are reserved for some specific agent properties      - pos : position     - vel : velocity     - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keepsrecordof : list of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_3d_agents","page":"API","title":"EasyABM.create_3d_agents","text":"create_3d_agents(n::Int64; kwargs...) -> Vector{EasyABM.AgentDict3D{Symbol, Any}}\n\n\nCreates a list of n 3d agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_graph_agent","page":"API","title":"EasyABM.create_graph_agent","text":"create_graph_agent(; kwargs...) -> EasyABM.AgentDictGr{Symbol, Any}\n\n\nCreates a single graph agent with properties specified as keyword arguments. Following property names are reserved for some specific agent properties      - node : node where the agent is located on the graph.      - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keepsrecordof : list of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_graph_agents","page":"API","title":"EasyABM.create_graph_agents","text":"create_graph_agents(n::Int64; kwargs...) -> Vector{EasyABM.AgentDictGr{Symbol, Any}}\n\n\nCreates a list of n graph agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_similar","page":"API","title":"EasyABM.create_similar","text":"create_similar(agent::EasyABM.AgentDict2D, n::Int64) -> Vector{EasyABM.AgentDict2D{Symbol, Any}}\n\n\nReturns a list of n 2d agents all having same properties as agent.  \n\n\n\n\n\ncreate_similar(agent::EasyABM.AgentDict2D) -> EasyABM.AgentDict2D{Symbol, Any}\n\n\nReturns an agent with same properties as given agent. \n\n\n\n\n\ncreate_similar(agent::EasyABM.AgentDictGr, n::Int64) -> Vector{EasyABM.AgentDictGr{Symbol, Any}}\n\n\nReturns a list of n graph agents all having same properties as agent.  \n\n\n\n\n\ncreate_similar(agent::EasyABM.AgentDictGr) -> EasyABM.AgentDictGr{Symbol, Any}\n\n\nReturns an agent with same properties as given agent. \n\n\n\n\n\ncreate_similar(agent::EasyABM.AgentDict3D, n::Int64) -> Vector{EasyABM.AgentDict3D{Symbol, Any}}\n\n\nReturns a list of n 3d agents all having same properties as agent.  \n\n\n\n\n\ncreate_similar(agent::EasyABM.AgentDict3D) -> EasyABM.AgentDict3D{Symbol, Any}\n\n\nReturns an agent with same properties as given agent. \n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-defining-model","page":"API","title":"Functions for defining model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"create_2d_model\ncreate_3d_model\ncreate_graph_model","category":"page"},{"location":"api/#EasyABM.create_2d_model","page":"API","title":"EasyABM.create_2d_model","text":"create_2d_model(agents::Vector{EasyABM.AgentDict2D{Symbol, Any}}; graphics, fix_agents_num, grid_size, periodic, random_positions, kwargs...) -> Union{EasyABM.GridModel2D{MortalType}, EasyABM.GridModel2D{StaticType}}\n\n\nCreates a model with \n\nagents : list of agents.\ngraphics : if true properties of pos, shape, color, orientation will be assigned to each agent by default, if not already assigned by the user.\nfix_agent_num : Set it to true if agents do not die and new agents are not born during simulation.\ngrid_size : A tuple (dimx, dimy) which tells the number of blocks the space is to be divided into along x and y directions. An agent can take\n\npositions from 0 to dimx in x-direction and 0 to dimy in y direction in order to stay within grid space. The word grid in the function create_grid_model does not imply that agents will be restricted to move in discrete steps. The agents can move continuously or  in discrete steps depending upon how user implements the step rule. Each grid block is called a patch which like agents can be assigned  its own properties.  Other than the number of patches in the model, grid_size will also restrict the domain of neighbors function  (which when called with either :grid or :euclidean metric option) will only take into account the agents within the grid dimensions and  will ignore any agents which have crossed the boundary of grid space(unless periodic is set to true). \n\nperiodic : If periodic is true the grid space will be periodic in both x and y directions. \nrandom_positions : If this property is true, each agent, which doesn't already have a position defined, will be given a default random continous position. \nkwargs : Keyword argments used as model parameters. \n\ncreate_2d_model(agents)\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_3d_model","page":"API","title":"EasyABM.create_3d_model","text":"create_3d_model(agents::Vector{EasyABM.AgentDict3D{Symbol, Any}}; graphics, fix_agents_num, grid_size, periodic, random_positions, kwargs...) -> Union{EasyABM.GridModel3D{MortalType}, EasyABM.GridModel3D{StaticType}}\n\n\nCreates a model with \n\nagents : list of agents.\ngraphics : if true properties of pos, shape, color, orientation will be assigned to each agent by default, if not already assigned by the user.\nfix_agent_num : Set it to true if agents do not die and new agents are not born during simulation. \ngrid_size : A tuple (dimx, dimy, dimz) which tells the number of blocks the space is to be divided into along x, y and z directions. An agent can take\n\npositions from 0 to dimx in x-direction, 0 to dimy in y direction and 0 to dimz in z direction in order to stay within grid space. The word grid in the function create_grid_model does not imply that agents will be restricted to move in discrete steps. The agents can move continuously or  in discrete steps depending upon how user implements the step rule. Each grid block is called a patch which like agents can be assigned  its own properties.  Other than the number of patches in the model, grid_size also restricts the domain of neighbors function  (which when called with either :grid or :euclidean metric option) will only take into account the agents within the grid dimensions and  will ignore any agents which have crossed the boundary of grid space(unless periodic is set to true). \n\nperiodic : If periodic is true the grid space will be periodic in x, y and z directions. \nrandom_positions : If this property is true, each agent, which doesn't already have a position defined, will be given a default random continous position. \nkwargs : Keyword argments used as model parameters. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_graph_model","page":"API","title":"EasyABM.create_graph_model","text":"create_graph_model(agents::Vector{EasyABM.AgentDictGr{Symbol, Any}}, graph::Union{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Graphs.SimpleGraphs.SimpleGraph{Int64}, EasyABM.DirPropGraph, EasyABM.SimplePropGraph}; fix_agents_num, static_graph, decorated_edges, graphics, random_positions, kwargs...) -> EasyABM.GraphModel\n\n\nCreates a model with \n\nagents : list of agents.\ngraph  : A graph created with Graph.jl or with SimpleABM graph functionality.\ngraphics : if true properties of pos, shape, color, orientation will be assigned to each agent by default, if not already assigned by user.\nfix_agent_num : Set it to true if agents do not die and new agents are not born during simulation. \nstatic_graph : Set it to false if graph topology needs to be changed during simulation.\ndecorated_edges : Set it to true if edges are to be assigned weights or any other properties.\nrandom_positions : If this property is true, each agent, which doesn't already have a node property defined, will be given a default random node on the graph. \nkwargs : Keyword argments used as model parameters. \n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-initialising,-running-and-visualising","page":"API","title":"Functions for initialising, running and visualising","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"init_model!\nrun_model!\nrun_model_epochs!\nanimate_sim\ncreate_interactive_app","category":"page"},{"location":"api/#EasyABM.init_model!","page":"API","title":"EasyABM.init_model!","text":"init_model!(model::EasyABM.GridModel2D; initialiser, props_to_record, keep_deads_data)\n\n\nInitiates the simulation with a user defined initialiser function which takes the model as its only argument.  Model parameters along with agent properties can be set (or modified if set through the create_2d_agents and create_2d_model  functions) from within a user defined function and then sending it as initialiser argument in init_model!. The properties of  agents, patches and model that are to be recorded during time evolution can be specified through the dictionary argument props_to_record.  List of agent properties to be recorded are specified with key \"agents\" and value the list of property names as symbols. If a nonempty list of  agents properties is specified, it will replace the keeps_record_of list of each agent. Properties of patches and model are similarly specified with keys \"patches\" and \"model\" respectively.\n\n\n\n\n\ninit_model!(model::EasyABM.GridModel3D; initialiser, props_to_record, keep_deads_data)\n\n\nInitiates the simulation with a user defined initialiser function which takes the model as its only argument.  Model parameters along with agent properties can be set (or modified if set through the create_3d_agents and create_3d_model  functions) from within a user defined function and then sending it as initialiser argument in init_model!. The properties of  agents, patches and model that are to be recorded during time evolution can be specified through the dictionary argument props_to_record.  List of agent properties to be recorded are specified with key \"agents\" and value the list of property names as symbols. If a nonempty list of  agents properties is specified, it will replace the keeps_record_of list of each agent. Properties of patches and model are similarly specified with keys \"patches\" and \"model\" respectively.\n\n\n\n\n\ninit_model!(model::EasyABM.GraphModel; initialiser, props_to_record, keep_deads_data)\n\n\nInitiates the simulation with a user defined initialiser function which takes the model as its only argument.  Model parameters along with agent and graph properties can be set (or modified if set through the create_graph_agents and create_graph_model  functions) from within a user defined function and then sending it as initialiser argument in init_model!. The properties of  agents, nodes, edges and the model that are to be recorded during time evolution can be specified through the dictionary argument props_to_record.  List of agent properties to be recorded are specified with key \"agents\" and value the list of property names as symbols. If a nonempty list of  agents properties is specified, it will replace the keeps_record_of list of each agent. Properties of nodes, edges and model are similarly specified with keys \"nodes\", \"edges\" and \"model\" respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.run_model!","page":"API","title":"EasyABM.run_model!","text":"run_model!(model::EasyABM.GridModel2D; steps, step_rule)\n\n\nRuns the simulation for steps number of steps.\n\n\n\n\n\nrun_model!(model::EasyABM.GridModel3D; steps, step_rule)\n\n\nRuns the simulation for steps number of steps.\n\n\n\n\n\nrun_model!(model::EasyABM.GraphModel; steps, step_rule)\n\n\nRuns the simulation for steps number of steps.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.run_model_epochs!","page":"API","title":"EasyABM.run_model_epochs!","text":"run_model_epochs!(model::EasyABM.GridModel2D; steps_per_epoch, num_epochs, step_rule, save_to_folder)\n\n\nRuns the simulation for num_epochs number of epochs where each epoch consists of steps_per_epoch number of steps. The model is saved as .jld2 file and the model.tick is reset to 1 at the end of each epoch.\n\n\n\n\n\nrun_model_epochs!(model::EasyABM.GridModel3D; steps_per_epoch, num_epochs, step_rule, save_to_folder)\n\n\nRuns the simulation for num_epochs number of epochs where each epoch consists of steps_per_epoch number of steps. The model is saved as .jld2 file and the model.tick is reset to 1 at the end of each epoch.\n\n\n\n\n\nrun_model_epochs!(model::EasyABM.GraphModel; steps_per_epoch, num_epochs, step_rule, save_to_folder)\n\n\nRuns the simulation for num_epochs number of epochs where each epoch consists of steps_per_epoch number of steps. The model is saved as .jld2 file and the model.tick is reset to 1 at the end of each epoch.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.animate_sim","page":"API","title":"EasyABM.animate_sim","text":"animate_sim(model::EasyABM.GridModel2D) -> Widgets.Widget{:default, Any}\nanimate_sim(model::EasyABM.GridModel2D, frames::Int64; agent_plots, patch_plots, model_plots, plots_only, path, show_grid, backend, tail) -> Widgets.Widget{:default, Any}\n\n\nCreates an animation from the data collected during model run.\n\n\n\n\n\nanimate_sim(model::EasyABM.GridModel3D) -> Union{Nothing, MeshCat.DisplayedVisualizer}\nanimate_sim(model::EasyABM.GridModel3D, frames::Int64; show_grid, tail) -> Union{Nothing, MeshCat.DisplayedVisualizer}\n\n\nCreates a 3d animation from the data collected during the model run.\n\n\n\n\n\nanimate_sim(model::EasyABM.GraphModel) -> Widgets.Widget{:default, Any}\nanimate_sim(model::EasyABM.GraphModel, frames::Int64; agent_plots, node_plots, model_plots, plots_only, path, show_graph, backend) -> Widgets.Widget{:default, Any}\n\n\nCreates an animation from the data collected during model run.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_interactive_app","page":"API","title":"EasyABM.create_interactive_app","text":"create_interactive_app(inmodel::EasyABM.GridModel2D; initialiser, props_to_record, step_rule, agent_controls, model_controls, agent_plots, patch_plots, model_plots, plots_only, path, frames, show_grid, backend, tail) -> Widgets.Widget{:default, Any}\n\n\nCreates an interactive app for the model.\n\n\n\n\n\ncreate_interactive_app(inmodel::EasyABM.GridModel3D; initialiser, props_to_record, step_rule, agent_controls, model_controls, agent_plots, patch_plots, model_plots, plots_only, frames, show_grid, tail) -> Widgets.Widget{:default, Any}\n\n\nCreates an interactive app for the model.\n\n\n\n\n\ncreate_interactive_app(inmodel::EasyABM.GraphModel; initialiser, props_to_record, step_rule, agent_controls, model_controls, agent_plots, node_plots, model_plots, plots_only, path, frames, show_graph, backend) -> Widgets.Widget{:default, Any}\n\n\nCreates an interactive app for the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-accessing,-saving-and-retrieving-data.","page":"API","title":"Functions for accessing, saving and retrieving data.","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_agent_data \nget_patch_data \nget_node_data\nget_edge_data \nget_model_data \nlatest_propvals\npropnames\nget_nums_agents \nget_nums_patches\nget_nums_nodes \nget_nums_edges\nget_agents_avg_props\nget_patches_avg_props\nget_nodes_avg_props\nget_edges_avg_props\nsave_model\nopen_saved_model","category":"page"},{"location":"api/#EasyABM.get_agent_data","page":"API","title":"EasyABM.get_agent_data","text":"get_agent_data(agent::EasyABM.AbstractPropDict, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, MortalType}, EasyABM.AbstractGridModel{MortalType}}) -> NamedTuple{(:birthtime, :deathtime, :record), _A} where _A<:Tuple{Any, Any, DataFrames.DataFrame}\nget_agent_data(agent::EasyABM.AbstractPropDict, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, MortalType}, EasyABM.AbstractGridModel{MortalType}}, props) -> NamedTuple{(:birthtime, :deathtime, :record), _A} where _A<:Tuple{Any, Any, DataFrames.DataFrame}\n\n\n\n\n\n\nget_agent_data(agent::EasyABM.AbstractPropDict, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, StaticType}, EasyABM.AbstractGridModel{StaticType}}) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\nget_agent_data(agent::EasyABM.AbstractPropDict, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, StaticType}, EasyABM.AbstractGridModel{StaticType}}, props) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_patch_data","page":"API","title":"EasyABM.get_patch_data","text":"get_patch_data(patch, model::EasyABM.AbstractGridModel) -> Union{Nothing, NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}}\nget_patch_data(patch, model::EasyABM.AbstractGridModel, props) -> Union{Nothing, NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_node_data","page":"API","title":"EasyABM.get_node_data","text":"get_node_data(node::Int64, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}) -> NamedTuple{(:birthtime, :deathtime, :record), _A} where _A<:Tuple{Any, Any, DataFrames.DataFrame}\nget_node_data(node::Int64, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}, props) -> NamedTuple{(:birthtime, :deathtime, :record), _A} where _A<:Tuple{Any, Any, DataFrames.DataFrame}\n\n\n\n\n\n\nget_node_data(node::Int64, model::Union{EasyABM.GraphModel{StaticType, MortalType}, EasyABM.GraphModel{StaticType, StaticType}}) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\nget_node_data(node::Int64, model::Union{EasyABM.GraphModel{StaticType, MortalType}, EasyABM.GraphModel{StaticType, StaticType}}, props) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_edge_data","page":"API","title":"EasyABM.get_edge_data","text":"get_edge_data(i::Int64, j::Int64, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}) -> NamedTuple{(:birthtime, :deathtime, :record), _A} where _A<:Tuple{Any, Any, DataFrames.DataFrame}\nget_edge_data(i::Int64, j::Int64, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}, props) -> NamedTuple{(:birthtime, :deathtime, :record), _A} where _A<:Tuple{Any, Any, DataFrames.DataFrame}\n\n\n\n\n\n\nget_edge_data(edge, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}) -> NamedTuple{(:birthtime, :deathtime, :record), _A} where _A<:Tuple{Any, Any, DataFrames.DataFrame}\nget_edge_data(edge, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}, props) -> NamedTuple{(:birthtime, :deathtime, :record), _A} where _A<:Tuple{Any, Any, DataFrames.DataFrame}\n\n\n\n\n\n\nget_edge_data(i::Int64, j::Int64, model::Union{EasyABM.GraphModel{StaticType, MortalType}, EasyABM.GraphModel{StaticType, StaticType}})\nget_edge_data(i::Int64, j::Int64, model::Union{EasyABM.GraphModel{StaticType, MortalType}, EasyABM.GraphModel{StaticType, StaticType}}, props)\n\n\n\n\n\n\nget_edge_data(edge, model::Union{EasyABM.GraphModel{StaticType, MortalType}, EasyABM.GraphModel{StaticType, StaticType}})\nget_edge_data(edge, model::Union{EasyABM.GraphModel{StaticType, MortalType}, EasyABM.GraphModel{StaticType, StaticType}}, props)\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_model_data","page":"API","title":"EasyABM.get_model_data","text":"get_model_data(model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractGridModel}) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\nget_model_data(model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractGridModel}, props) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.latest_propvals","page":"API","title":"EasyABM.latest_propvals","text":"latest_propvals(obj::EasyABM.AbstractPropDict, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(agent::EasyABM.AbstractPropDict, model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractGridModel}, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(patch, model::EasyABM.AbstractGridModel, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(node::Int64, model::EasyABM.GraphModel, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(i::Int64, j::Int64, model::EasyABM.GraphModel, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(edge, model::EasyABM.GraphModel, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.propnames","page":"API","title":"EasyABM.propnames","text":"propnames(obj::EasyABM.AbstractPropDict) -> Vector{Symbol}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nums_agents","page":"API","title":"EasyABM.get_nums_agents","text":"\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nums_patches","page":"API","title":"EasyABM.get_nums_patches","text":"get_nums_patches(model::EasyABM.AbstractGridModel, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nums_nodes","page":"API","title":"EasyABM.get_nums_nodes","text":"get_nums_nodes(model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_nums_nodes(model::Union{EasyABM.GraphModel{StaticType, MortalType}, EasyABM.GraphModel{StaticType, StaticType}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nums_edges","page":"API","title":"EasyABM.get_nums_edges","text":"get_nums_edges(model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_nums_edges(model::Union{EasyABM.GraphModel{StaticType, MortalType}, EasyABM.GraphModel{StaticType, StaticType}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_agents_avg_props","page":"API","title":"EasyABM.get_agents_avg_props","text":"get_agents_avg_props(model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, MortalType}, EasyABM.AbstractGridModel{MortalType}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_agents_avg_props(model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, StaticType}, EasyABM.AbstractGridModel{StaticType}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_patches_avg_props","page":"API","title":"EasyABM.get_patches_avg_props","text":"get_patches_avg_props(model::EasyABM.AbstractGridModel, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nodes_avg_props","page":"API","title":"EasyABM.get_nodes_avg_props","text":"get_nodes_avg_props(model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_nodes_avg_props(model::Union{EasyABM.GraphModel{StaticType, MortalType}, EasyABM.GraphModel{StaticType, StaticType}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_edges_avg_props","page":"API","title":"EasyABM.get_edges_avg_props","text":"get_edges_avg_props(model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_edges_avg_props(model::Union{EasyABM.GraphModel{StaticType, MortalType}, EasyABM.GraphModel{StaticType, StaticType}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.save_model","page":"API","title":"EasyABM.save_model","text":"save_model(model; model_name, save_as, folder) -> Union{Nothing, Int64}\n\n\nSaves the model on disk as jld2 file. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.open_saved_model","page":"API","title":"EasyABM.open_saved_model","text":"open_saved_model(; model_name, path) -> Any\n\n\nGets the model that was saved before as jld2. \n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-creating-and-modifying-a-graph","page":"API","title":"Functions for creating and modifying a graph","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"create_simple_graph\ncreate_dir_graph\nhex_grid\nsquare_grid\ntriangular_grid\ndouble_triangular_grid\ndraw_graph\nadd_node!\nkill_node!\ncreate_edge! \nkill_edge!\nis_digraph\nis_static","category":"page"},{"location":"api/#EasyABM.create_simple_graph","page":"API","title":"EasyABM.create_simple_graph","text":"create_simple_graph(n::Int64; gtype) -> EasyABM.SimplePropGraph{StaticType}\n\n\nCreates a simple prop graph with n vertices. \n\n\n\n\n\ncreate_simple_graph(structure::Dict{Int64, Vector{Int64}}; gtype) -> Union{Nothing, EasyABM.SimplePropGraph{StaticType}}\n\n\nCreates a simple prop graph with given structure. \n\n\n\n\n\ncreate_simple_graph(A::Matrix{Int64}; gtype) -> Union{Nothing, EasyABM.SimplePropGraph{StaticType}}\n\n\nCreates a simple prop graph for given Adjacency matrix. \n\n\n\n\n\ncreate_simple_graph(A::SparseArrays.SparseMatrixCSC{Int64, Int64}; gtype) -> Union{Nothing, EasyABM.SimplePropGraph{StaticType}}\n\n\nCreates a simple prop graph for adjacency_matrix given as a Sparse Matrix. \n\n\n\n\n\ncreate_simple_graph(g::Graphs.SimpleGraphs.SimpleGraph{Int64}; gtype) -> Union{Nothing, EasyABM.SimplePropGraph}\n\n\nCreates a simple prop graph from a given simple graph created with Graphs.jl. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_dir_graph","page":"API","title":"EasyABM.create_dir_graph","text":"create_dir_graph(n::Int64; gtype) -> EasyABM.DirPropGraph{StaticType}\n\n\nCreates a directed prop graph with n vertices. \n\n\n\n\n\ncreate_dir_graph(in_structure::Dict{Int64, Vector{Int64}}; gtype) -> Union{Nothing, EasyABM.DirPropGraph{StaticType}}\n\n\nCreates a directed prop graph with given structure. \n\n\n\n\n\ncreate_dir_graph(A::Matrix{Int64}; gtype) -> Union{Nothing, EasyABM.DirPropGraph{StaticType}}\n\n\nCreates a directed prop graph for given Adjacency matrix. \n\n\n\n\n\ncreate_dir_graph(A::SparseArrays.SparseMatrixCSC{Int64, Int64}; gtype) -> Union{Nothing, EasyABM.DirPropGraph{StaticType}}\n\n\nCreates a directed prop graph for adjacency matrix given as a Sparse Matrix. \n\n\n\n\n\ncreate_dir_graph(g::Graphs.SimpleGraphs.SimpleDiGraph{Int64}; gtype) -> Union{Nothing, EasyABM.DirPropGraph}\n\n\nCreates a directed prop graph for a given directed graph created with Graphs.jl. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.hex_grid","page":"API","title":"EasyABM.hex_grid","text":"hex_grid(n, k) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.square_grid","page":"API","title":"EasyABM.square_grid","text":"square_grid(n, k; periodic) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.triangular_grid","page":"API","title":"EasyABM.triangular_grid","text":"triangular_grid(n, k) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.double_triangular_grid","page":"API","title":"EasyABM.double_triangular_grid","text":"double_triangular_grid(n, k) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.draw_graph","page":"API","title":"EasyABM.draw_graph","text":"draw_graph(graph) -> Union{Nothing, Luxor.Drawing}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.add_node!","page":"API","title":"EasyABM.add_node!","text":"add_node!(model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}; kwargs...) -> Any\n\n\nAdds a node with properties specified in kwargs to the model's graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.kill_node!","page":"API","title":"EasyABM.kill_node!","text":"kill_node!(node, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}) -> Any\n\n\nRemoves a node from model graph. For performance reasons the function does not check if the node contains the node so it will throw an error if the user tries to delete a node which is not there. Also the node will not be deleted if the agents in the model can not be killed and the number of agents at the given node is nonzero.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_edge!","page":"API","title":"EasyABM.create_edge!","text":"create_edge!(i, j, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}; kwargs...)\n\n\nAdds an edge with properties kwargs to model graph. \n\n\n\n\n\ncreate_edge!(edge, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}; kwargs...)\n\n\nAdds an edge with properties kwargs to model graph. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.kill_edge!","page":"API","title":"EasyABM.kill_edge!","text":"kill_edge!(i, j, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}) -> Union{Nothing, Dict{Tuple{Int64, Int64}, EasyABM.PropDataDict{Symbol, Any}}}\n\n\nRemoves edge from the model graph. \n\n\n\n\n\nkill_edge!(edge, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{MortalType, StaticType}}) -> Union{Nothing, Dict{Tuple{Int64, Int64}, EasyABM.PropDataDict{Symbol, Any}}}\n\n\nRemoves edge from the model graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.is_digraph","page":"API","title":"EasyABM.is_digraph","text":"is_digraph(g::EasyABM.SimplePropGraph) -> Bool\n\n\n\n\n\n\nis_digraph(g::EasyABM.DirPropGraph) -> Bool\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.is_static","page":"API","title":"EasyABM.is_static","text":"is_static(g::EasyABM.SimplePropGraph) -> Bool\n\n\n\n\n\n\nis_static(g::EasyABM.DirPropGraph) -> Bool\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Helper-functions-for-agents","page":"API","title":"Helper functions for agents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_grid_loc\nget_node_loc\nget_id\nagents_at\nnum_agents_at\nagent_with_id\nis_alive\nget_agents \nnum_agents \nkill_agent!\nadd_agent!","category":"page"},{"location":"api/#EasyABM.get_grid_loc","page":"API","title":"EasyABM.get_grid_loc","text":"get_grid_loc(agent::EasyABM.AbstractPropDict, model::EasyABM.AbstractGridModel) -> Any\n\n\nReturns grid location of the agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_node_loc","page":"API","title":"EasyABM.get_node_loc","text":"get_node_loc(agent::EasyABM.AbstractPropDict, model::EasyABM.AbstractGraphModel) -> Any\n\n\nReturns node location of the agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_id","page":"API","title":"EasyABM.get_id","text":"get_id(agent::EasyABM.AbstractPropDict) -> Any\n\n\nReturns agents id.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.agents_at","page":"API","title":"EasyABM.agents_at","text":"agents_at(patch, model::EasyABM.AbstractGridModel) -> Any\n\n\nReturns list of agents at a given patch.\n\n\n\n\n\nagents_at(node, model::EasyABM.AbstractGraphModel) -> Any\n\n\nReturns list of agents at a given node. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_agents_at","page":"API","title":"EasyABM.num_agents_at","text":"num_agents_at(patch, model::EasyABM.AbstractGridModel) -> Any\n\n\nReturns number of agents at a given patch.\n\n\n\n\n\nnum_agents_at(node, model::EasyABM.AbstractGraphModel) -> Any\n\n\nReturns number of agents at a given node. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.agent_with_id","page":"API","title":"EasyABM.agent_with_id","text":"agent_with_id(i, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, MortalType}, EasyABM.AbstractGridModel{MortalType}}) -> Any\n\n\nReturns agent having given id.\n\n\n\n\n\nagent_with_id(i, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, StaticType}, EasyABM.AbstractGridModel{StaticType}}) -> Any\n\n\nReturns agent having given id.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.is_alive","page":"API","title":"EasyABM.is_alive","text":"is_alive(agent::EasyABM.AbstractPropDict) -> Any\n\n\nReturns true if agent is alive else returns false.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_agents","page":"API","title":"EasyABM.get_agents","text":"get_agents(model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, MortalType}, EasyABM.AbstractGridModel{MortalType}}) -> Any\nget_agents(model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, MortalType}, EasyABM.AbstractGridModel{MortalType}}, condition::Function) -> Any\n\n\n\n\n\n\nget_agents(model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, StaticType}, EasyABM.AbstractGridModel{StaticType}}) -> Any\nget_agents(model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, StaticType}, EasyABM.AbstractGridModel{StaticType}}, condition::Function) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_agents","page":"API","title":"EasyABM.num_agents","text":"num_agents(model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractGridModel}) -> Any\nnum_agents(model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractGridModel}, condition::Function) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.kill_agent!","page":"API","title":"EasyABM.kill_agent!","text":"kill_agent!(agent::EasyABM.AbstractPropDict, model::EasyABM.AbstractGridModel{MortalType}) -> Any\n\n\nSets the agent as inactive thus effectively removing from the model. However, the removed agents  are permanently removed from the list model.agents only twice in one step i) After the agent_step_function  has run for all agents and ii) After the step_rule.\n\n\n\n\n\nSets the agent as inactive thus effectively removing from the model. However, the removed agents  are permanently removed from the list model.agents only after each step.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.add_agent!","page":"API","title":"EasyABM.add_agent!","text":"add_agent!(agent, model::EasyABM.GridModel2D{MortalType}) -> Any\n\n\nAdds the agent to the model.\n\n\n\n\n\nadd_agent!(agent, model::EasyABM.GridModel3D{MortalType}) -> Any\n\n\nAdds the agent to the model.\n\n\n\n\n\nadd_agent!(agent, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{StaticType, MortalType}}) -> Any\n\n\nAdds the agent to the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-getting-neighbor-agents.","page":"API","title":"Functions for getting neighbor agents.","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"neighbors\nin_neighbors\nout_neighbors","category":"page"},{"location":"api/#EasyABM.neighbors","page":"API","title":"EasyABM.neighbors","text":"neighbors(agent::EasyABM.AgentDict2D, model::EasyABM.GridModel2D{MortalType}) -> Union{Nothing, Vector{EasyABM.AgentDict2D{Symbol, Any}}}\nneighbors(agent::EasyABM.AgentDict2D, model::EasyABM.GridModel2D{MortalType}, dist::Number; metric) -> Union{Nothing, Vector{EasyABM.AgentDict2D{Symbol, Any}}}\n\n\nReturns active neighboring agents to given agent. If the metric is :grid, then with dist =0 only agents present in the current  block of the given agent are returned; with dist=1, agents in the current block of the given agent along with agents in the neighbouring  8 blocks are returned; with dist=2 agents in the current block of given agent, along with agents in 24 nearest blocks are returned, and  so on. With metric = :euclidean the agents within Euclidean distance dist are returned.\n\n\n\n\n\nneighbors(agent::EasyABM.AgentDict2D, model::EasyABM.GridModel2D{StaticType}) -> Union{Nothing, Vector{EasyABM.AgentDict2D{Symbol, Any}}}\nneighbors(agent::EasyABM.AgentDict2D, model::EasyABM.GridModel2D{StaticType}, dist::Number; metric) -> Union{Nothing, Vector{EasyABM.AgentDict2D{Symbol, Any}}}\n\n\nReturns active neighboring agents to given agent. If the metric is :grid, then with dist =0 only agents present in the current  block of the given agent are returned; with dist=1, agents in the current block of the given agent along with agents in the neighbouring  8 blocks are returned; with dist=2 agents in the current block of given agent, along with agents in 24 nearest blocks are returned, and  so on. With metric = :euclidean the agents within Euclidean distance dist are returned.\n\n\n\n\n\nneighbors(agent::EasyABM.AgentDict3D, model::EasyABM.GridModel3D{MortalType}) -> Vector{EasyABM.AgentDict3D{Symbol, Any}}\nneighbors(agent::EasyABM.AgentDict3D, model::EasyABM.GridModel3D{MortalType}, dist::Number; metric) -> Vector{EasyABM.AgentDict3D{Symbol, Any}}\n\n\nReturns active neighboring agents to given agent. If the metric is :grid, then with dist =0 only agents present in the current  block of the given agent are returned; with dist=1, agents in the current block of the given agent along with agents in the neighbouring  8 blocks are returned; with dist=2 agents in the current block of given agent, along with agents in 24 nearest blocks are returned, and  so on. With metric = :euclidean the agents within Euclidean distance dist are returned.\n\n\n\n\n\nneighbors(agent::EasyABM.AgentDict3D, model::EasyABM.GridModel3D{StaticType}) -> Vector{EasyABM.AgentDict3D{Symbol, Any}}\nneighbors(agent::EasyABM.AgentDict3D, model::EasyABM.GridModel3D{StaticType}, dist::Number; metric) -> Vector{EasyABM.AgentDict3D{Symbol, Any}}\n\n\nReturns active neighboring agents to given agent. If the metric is :grid, then with dist =0 only agents present in the current  block of the given agent are returned; with dist=1, agents in the current block of the given agent along with agents in the neighbouring  8 blocks are returned; with dist=2 agents in the current block of given agent, along with agents in 24 nearest blocks are returned, and  so on. With metric = :euclidean the agents within Euclidean distance dist are returned.\n\n\n\n\n\nneighbors(agent::EasyABM.AgentDictGr, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{StaticType, MortalType}}) -> Vector{EasyABM.AgentDictGr{Symbol, Any}}\n\n\nReturns agents on neighboring nodes of given agent.\n\n\n\n\n\nneighbors(agent::EasyABM.AgentDictGr, model::Union{EasyABM.GraphModel{MortalType, StaticType}, EasyABM.GraphModel{StaticType, StaticType}}) -> Vector{EasyABM.AgentDictGr{Symbol, Any}}\n\n\nReturns agents on neighboring nodes of given agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.in_neighbors","page":"API","title":"EasyABM.in_neighbors","text":"in_neighbors(agent::EasyABM.AgentDictGr, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{StaticType, MortalType}}) -> Vector{EasyABM.AgentDictGr{Symbol, Any}}\n\n\nReturns agents on neighboring incoming nodes of given agent.\n\n\n\n\n\nin_neighbors(agent::EasyABM.AgentDictGr, model::Union{EasyABM.GraphModel{MortalType, StaticType}, EasyABM.GraphModel{StaticType, StaticType}}) -> Vector{EasyABM.AgentDictGr{Symbol, Any}}\n\n\nReturns agents on neighboring incoming nodes of given agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.out_neighbors","page":"API","title":"EasyABM.out_neighbors","text":"out_neighbors(agent::EasyABM.AgentDictGr, model::Union{EasyABM.GraphModel{MortalType, MortalType}, EasyABM.GraphModel{StaticType, MortalType}}) -> Vector{EasyABM.AgentDictGr{Symbol, Any}}\n\n\nReturns agents on neighboring outgoing nodes of given agent.\n\n\n\n\n\nout_neighbors(agent::EasyABM.AgentDictGr, model::Union{EasyABM.GraphModel{MortalType, StaticType}, EasyABM.GraphModel{StaticType, StaticType}}) -> Vector{EasyABM.AgentDictGr{Symbol, Any}}\n\n\nReturns agents on neighboring outgoing nodes of given agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#Helper-functions-for-patches,-nodes,-edges","page":"API","title":"Helper functions for patches, nodes, edges","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"is_occupied\nget_nodeprop\nget_edgeprop\nset_nodeprops!\nset_edgeprops!\nget_patchprop\nset_patchprops!\nneighbor_nodes\nneighbor_patches\nin_neighbor_nodes\nout_neighbor_nodes\nget_nodes\nnum_nodes\nget_edges\nnum_edges\nget_patches\nnum_patches\nrandom_empty_node\nrandom_empty_patch","category":"page"},{"location":"api/#EasyABM.is_occupied","page":"API","title":"EasyABM.is_occupied","text":"is_occupied(patch, model::EasyABM.AbstractGridModel) -> Any\n\n\nReturns true if a patch is occupied.\n\n\n\n\n\nis_occupied(node, model::EasyABM.AbstractGraphModel) -> Any\n\n\nReturns true if a node is occupied. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nodeprop","page":"API","title":"EasyABM.get_nodeprop","text":"get_nodeprop(key::Symbol, node::Int64, model::EasyABM.GraphModel) -> Any\n\n\nReturns the value for given property name for a node.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_edgeprop","page":"API","title":"EasyABM.get_edgeprop","text":"get_edgeprop(key::Symbol, i::Int64, j::Int64, model::EasyABM.GraphModel) -> Any\n\n\nReturns the value for given property name for an edge.\n\n\n\n\n\nget_edgeprop(key::Symbol, edge, model::EasyABM.GraphModel) -> Any\n\n\nReturns the value for given property name for an edge.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.set_nodeprops!","page":"API","title":"EasyABM.set_nodeprops!","text":"set_nodeprops!(node::Int64, model::EasyABM.GraphModel; kwargs...)\n\n\nSets properties of given node.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.set_edgeprops!","page":"API","title":"EasyABM.set_edgeprops!","text":"set_edgeprops!(i::Int64, j::Int64, model::EasyABM.GraphModel; kwargs...)\n\n\nSets properties of given edge.\n\n\n\n\n\nset_edgeprops!(edge, model::EasyABM.GraphModel; kwargs...)\n\n\nSets properties of given edge.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_patchprop","page":"API","title":"EasyABM.get_patchprop","text":"get_patchprop(key, patch, model::EasyABM.AbstractGridModel) -> Any\n\n\nReturns value of given property of a patch. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.set_patchprops!","page":"API","title":"EasyABM.set_patchprops!","text":"set_patchprops!(patch, model::EasyABM.AbstractGridModel; kwargs...)\n\n\nSets properties of the patch given as keyword arguments. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.neighbor_nodes","page":"API","title":"EasyABM.neighbor_nodes","text":"neighbor_nodes(node::Int64, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes neighboring given node.\n\n\n\n\n\nneighbor_nodes(agent::EasyABM.AgentDictGr, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes neighboring node of the given agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.neighbor_patches","page":"API","title":"EasyABM.neighbor_patches","text":"neighbor_patches(agent::EasyABM.AgentDict2D, model::EasyABM.GridModel2D, dist::Int64) -> Vector{Tuple{Int64, Int64}}\n\n\nReturns patches neighboring the given agent's patch.\n\n\n\n\n\nneighbor_patches(patch::Tuple{Int64, Int64}, model::EasyABM.GridModel2D, dist::Int64) -> Vector{Tuple{Int64, Int64}}\n\n\nReturns patches neighboring the given patch.\n\n\n\n\n\nneighbor_patches(agent::EasyABM.AgentDict3D, model::EasyABM.GridModel3D, dist::Int64) -> Vector{Tuple{Int64, Int64, Int64}}\n\n\nReturns patches neighboring given agent's patch.\n\n\n\n\n\nneighbor_patches(patch::Tuple{Int64, Int64, Int64}, model::EasyABM.GridModel3D, dist::Int64) -> Vector{Tuple{Int64, Int64, Int64}}\n\n\nReturning patches neighboring given patch.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.in_neighbor_nodes","page":"API","title":"EasyABM.in_neighbor_nodes","text":"in_neighbor_nodes(node::Int64, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes of incoming edges at given node. \n\n\n\n\n\nin_neighbor_nodes(agent::EasyABM.AgentDictGr, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes of incoming edges at given agent's node.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.out_neighbor_nodes","page":"API","title":"EasyABM.out_neighbor_nodes","text":"out_neighbor_nodes(node::Int64, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes of outgoing edges at given node.\n\n\n\n\n\nout_neighbor_nodes(agent::EasyABM.AgentDictGr, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes of outgoing edges at given agent's node.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nodes","page":"API","title":"EasyABM.get_nodes","text":"get_nodes(model::EasyABM.GraphModel) -> Vector{Int64}\nget_nodes(model::EasyABM.GraphModel, condition::Function) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_nodes","page":"API","title":"EasyABM.num_nodes","text":"num_nodes(model::EasyABM.GraphModel) -> Any\nnum_nodes(model::EasyABM.GraphModel, condition::Function) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_edges","page":"API","title":"EasyABM.get_edges","text":"get_edges(model::EasyABM.GraphModel) -> Vector{Tuple{Int64, Int64}}\nget_edges(model::EasyABM.GraphModel, condition::Function) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_edges","page":"API","title":"EasyABM.num_edges","text":"num_edges(model::EasyABM.GraphModel) -> Any\nnum_edges(model::EasyABM.GraphModel, condition::Function) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_patches","page":"API","title":"EasyABM.get_patches","text":"get_patches(model::EasyABM.GridModel2D) -> Any\nget_patches(model::EasyABM.GridModel2D, condition::Function) -> Any\n\n\nReturns patches satisfying the given condition.\n\n\n\n\n\nget_patches(model::EasyABM.GridModel3D) -> Any\nget_patches(model::EasyABM.GridModel3D, condition::Function) -> Any\n\n\nReturns patches satisfying given condition.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_patches","page":"API","title":"EasyABM.num_patches","text":"num_patches(model::EasyABM.GridModel2D) -> Any\nnum_patches(model::EasyABM.GridModel2D, condition::Function) -> Any\n\n\nReturns number of patches satisfying the given condition.\n\n\n\n\n\nnum_patches(model::EasyABM.GridModel3D) -> Any\nnum_patches(model::EasyABM.GridModel3D, condition::Function) -> Any\n\n\nReturns number of patches satisfying given condition.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.random_empty_node","page":"API","title":"EasyABM.random_empty_node","text":"random_empty_node(model::EasyABM.AbstractGraphModel) -> Any\n\n\nReturns an empty node chosen at random. Returns missing if there is no empty node. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.random_empty_patch","page":"API","title":"EasyABM.random_empty_patch","text":"random_empty_patch(model::EasyABM.GridModel2D) -> Any\n\n\nReturns a random patch where no agents are present. Rerurns missing if there is no such patch.\n\n\n\n\n\nrandom_empty_patch(model::EasyABM.GridModel3D) -> Any\n\n\nReturns a random patch where no agents are present. Returns missing if there is no such patch.\n\n\n\n\n\n","category":"function"},{"location":"api/#Misc.-utility-functions","page":"API","title":"Misc. utility functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"dotproduct\nnorm\ndistance\ncalculate_direction","category":"page"},{"location":"api/#EasyABM.dotproduct","page":"API","title":"EasyABM.dotproduct","text":"dotproduct(a::GeometryBasics.Vec, b::GeometryBasics.Vec) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.norm","page":"API","title":"EasyABM.norm","text":"norm(a::GeometryBasics.Vec) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.distance","page":"API","title":"EasyABM.distance","text":"distance(a::GeometryBasics.Vec, b::GeometryBasics.Vec) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.calculate_direction","page":"API","title":"EasyABM.calculate_direction","text":"calculate_direction(vel::GeometryBasics.Vec2{Float64}) -> Union{Nothing, Float64}\n\n\n\n\n\n\ncalculate_direction(vel::GeometryBasics.Vec3{Float64}) -> Union{Float64, GeometryBasics.Vec3{Float64}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"boids/#Flocking","page":"Flocking","title":"Flocking","text":"","category":"section"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"using EasyABM","category":"page"},{"location":"boids/#Step-1:-Create-Agents-and-Model","page":"Flocking","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"Lets create 200 agents with properties shape, pos, vel and orientation (The orientation property is used internally by EasyABM to draw the direction agent is facing). The keeps_record_of argument is list of properties that the agent will record during time evolution. The model is defined with parameters:","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"min_dis : The distance between boids below which they start repelling each other.\ncoh_fac : The proportionality constant for the cohere force. \nsep_fac : The proportionality constant for the separation force.\naln_fac : The proportionality constant for the alignment force.\nvis_range : The visual range of boids.\ndt : The proportionality constant between change in position and velocity.","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"The argument fix_agents_num is set to true which means that the boids number will remain fixed during simulation. ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"boids = create_2d_agents(200, shape = :arrow, pos = (0.0,0.0), \n    vel=(0.0,0.0), orientation = 0.0, keeps_record_of = [:pos, :vel, :orientation])\nmodel = create_2d_model(boids,fix_agents_num=true, min_dis = 0.3, coh_fac = 0.05, \n    sep_fac = 0.5, dt= 0.1, vis_range = 2.0, aln_fac = 0.35, periodic = true)","category":"page"},{"location":"boids/#Step-2:-Initialise-the-model","page":"Flocking","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"In this step we set the positions, velocities and orientations of boids and initialise the model.","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"function initialiser!(model)\n    xdim, ydim = model.size\n    for boid in model.agents\n        boid.pos = (rand()*xdim, rand()*ydim)\n        boid.orientation = rand()*2*3.14\n        boid.vel = (-sin(boid.orientation), cos(boid.orientation))\n    end\nend\n\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"boids/#Step-3:-Run-the-model","page":"Flocking","title":"Step 3: Run the model","text":"","category":"section"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"In this step we implement the step logic of the flocking model in the step_rule! function and run the model for 500 steps. ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"\nusing GeometryBasics # used to represent forces as Vec\n\nconst ep = 0.00001\n\nfunction step_rule!(model)\n    dt = model.parameters.dt\n    for boid in model.agents\n        nbrs = neighbors(boid, model, model.parameters.vis_range)\n        coh_force = Vec(0.0,0) \n        sep_force = Vec(0.0,0) \n        aln_force = Vec(0.0,0)\n        num = 0\n        for nbr in nbrs\n            num+=1\n            vec = nbr.pos - boid.pos\n            coh_force += vec\n            if norm(vec)< model.parameters.min_dis\n                sep_force -= vec\n            end\n            aln_force += nbr.vel\n        end\n        aln_force = num>0 ? (aln_force/ num - boid.vel)*model.parameters.aln_fac : aln_force\n        num = max(1, num)\n        coh_force *= (model.parameters.coh_fac/num)\n        sep_force *=  model.parameters.sep_fac\n        boid.vel  += (coh_force + sep_force) + aln_force\n        boid.vel  /= (norm(boid.vel)+ep)\n        boid.orientation = calculate_direction(boid.vel)\n        boid.pos += boid.vel*dt\n    end\nend\n\nrun_model!(model, steps=500, step_rule = step_rule!)","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"animate_sim(model)","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"(Image: png)","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[(:min_dis, :s, 0.01:0.1:1.0),\n        (:coh_fac, :s, 0.01:0.01:1.0),\n        (:sep_fac, :s, 0.01:0.01:1.0),\n        (:aln_fac, :s, 0.01:0.01:1.0),\n        (:vis_range, :s, 0.5:0.5:4.0)], frames=400) ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"(Image: png)","category":"page"},{"location":"boids/#Step-4:-Fetch-Data","page":"Flocking","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"It is easy to fetch any data recorded during simulation. For example, the data of average velocity of agents at each time step can be obtained as - ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"df = get_agents_avg_props(model, agent -> agent.vel, labels = [\"average velocity\"])","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"stone_paper_scissor/#Stone-Paper-Scissor","page":"Rock-Paper-Scissor","title":"Stone Paper Scissor","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"using EasyABM","category":"page"},{"location":"stone_paper_scissor/#Step-1:-Create-Model","page":"Rock-Paper-Scissor","title":"Step 1: Create Model","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"In this model, we work with patches instead of agents. As agents is the first field required in the create_2d_model function, so for syntactical correctness we create a list of 0 agents, and use it as first argument of create_2d_model function. We set grid_size to (50,50), set periodic to true and define an additional model parameter threshold whose value is set to 2. ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"agents = create_2d_agents(0) \nmodel = create_2d_model(agents, grid_size = (50,50), threshold = 2, periodic = true)","category":"page"},{"location":"stone_paper_scissor/#Step-2:-Initialise-the-model","page":"Rock-Paper-Scissor","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"In the second step we initialise the agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function randomly assign :red (for stone), :green (for paper) and :blue (for scissor) color to patches. Then we initialise the model using init_model! function, in which through the argument props_to_record, we tell EasyABM to record the :color property of patches during time evolution. Note that, in EasyABM animations are created with the recorded data, therefore if in the present model, the color of patches is not recorded there will there will be no animation to see. ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"function initialiser!(model)\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            num = rand()\n            if num<0.33\n                model.patches[i,j].color = :red # stone => red, paper => green, scissor => blue\n            elseif num>0.66\n                model.patches[i,j].color = :green\n            else\n                model.patches[i,j].color = :blue\n            end\n        end\n    end\nend\n\ninit_model!(model, initialiser = initialiser!, props_to_record = Dict(\"patches\" => [:color]))","category":"page"},{"location":"stone_paper_scissor/#Step-3:-Run-the-model","page":"Rock-Paper-Scissor","title":"Step 3: Run the model","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"In this step we define the step_rule! function and run the model for 400 steps. The rule of the game is very simple. The :red color of a patch will change to :green if number of neighboring patches with color :green exceeds the threshold( which we set to be 2 in the beginning). Similarly, if a :green patch finds larger than the threshold number of :blue patches in its neighborhood, it will change to :blue, and if a :blue patch finds larger than threshold number of :red patches in its neighborhood it will change to :red. Each step of the model consists of 500 Monte-Carlo steps in which a patch is selected at random and the above mentioned rule applied to it. ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"const who_wins_against = Dict(:red => :green, :green => :blue, :blue => :red)\n\nfunction step_rule!(model)\n    for _ in 1:500\n        i = rand(1:model.size[1])\n        j = rand(1:model.size[2])\n        nbr_patches = neighbor_patches((i,j), model, 1)\n        col = model.patches[i,j].color\n        winner_col = who_wins_against[col]\n        count = 0 \n        for patch in nbr_patches\n            if model.patches[patch...].color == winner_col\n                count+=1\n            end\n        end\n        if count > model.parameters.threshold\n            model.patches[i,j].color = winner_col\n        end\n    end\nend\n\nrun_model!(model, steps = 400, step_rule = step_rule!)","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"animate_sim(model, show_grid=true)","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"(Image: png)","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"Once the model has been run it can be saved to the disk as a jld2 file using following function.","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"save_model(model, model_name = \"sps_model\", save_as = \"stone_paper_scissor.jld2\", folder = \"/path/to/folder/\")","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"A model saved previously as jld2 file, can be fetched as follows ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"model = open_saved_model(model_name = \"sps_model\", path = \"/path/to/folder/stone_paper_scissor.jld2\")","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"create_interactive_app(model, initialiser= initialiser!,\n    props_to_record = Dict(\"patches\" => [:color]),\n    step_rule= step_rule!,\n    model_controls=[(:threshold, :s, 1:8)], \n    frames=400, show_grid=true) ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"(Image: png)","category":"page"},{"location":"stone_paper_scissor/#Step-4:-Fetch-Data","page":"Rock-Paper-Scissor","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"It is easy to fetch any recorded data after running the model. For example, the numbers of different colored patches at all timesteps can be got as follows","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"df = get_nums_patches(model, \n    patch-> patch.color ==:red, \n    patch-> patch.color ==:green, \n    patch-> patch.color ==:blue, labels=[\"stone\",\"paper\",\"scissor\"], plot_result=true)","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"(Image: png)","category":"page"},{"location":"boids3d/#Flocking","page":"Flocking","title":"Flocking","text":"","category":"section"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"using EasyABM","category":"page"},{"location":"boids3d/#Step-1:-Create-Agents-and-Model","page":"Flocking","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"Lets create 200 agents with properties shape, pos, vel and orientation (The orientation property is used internally by EasyABM to draw the direction agent is facing). The keeps_record_of argument is list of properties that the agent will record during time evolution. The model is defined with parameters:","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"min_dis : The distance between boids below which they start repelling each other.\ncoh_fac : The proportionality constant for the cohere force. \nsep_fac : The proportionality constant for the separation force.\naln_fac : The proportionality constant for the alignment force.\nvis_range : The visual range of boids.\ndt : The proportionality constant between change in position and velocity.","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"The argument fix_agents_num is set to true which means that the boids number will remain fixed during simulation. ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"boids = create_3d_agents(200, shape = :cone, pos = (0.0,0.0,0.0), \n    vel=(0.0,0.0,0.0), orientation = 0.0, keeps_record_of = [:pos, :orientation])\nmodel = create_3d_model(boids,fix_agents_num=true, min_dis = 0.3, coh_fac = 0.05, \n    sep_fac = 0.5, dt= 0.1, vis_range = 2.0, aln_fac = 0.35, periodic = true)","category":"page"},{"location":"boids3d/#Step-2:-Initialise-the-model","page":"Flocking","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"In this step we set the positions, velocities and orientations of boids and initialise the model.","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"function initialiser!(model)\n    xdim, ydim, zdim = model.size\n    for boid in model.agents\n        boid.pos = (rand()*xdim, rand()*ydim, rand()*zdim)\n        boid.vel = (1-2*rand(), 1-2*rand(), 1-2*rand())\n        boid.vel /= norm(boid.vel)\n        boid.orientation = boid.vel\n    end\nend\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"boids3d/#Step-3:-Run-the-model","page":"Flocking","title":"Step 3: Run the model","text":"","category":"section"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"In this step we implement the step logic of the flocking model in the step_rule! function and run the model for 500 steps. ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"\nusing GeometryBasics # used to represent forces as Vec\n\nconst ep = 0.00001 # to avoid division by zero\n\nfunction step_rule!(model)\n    dt = model.parameters.dt\n    for boid in model.agents\n        nbrs = neighbors(boid, model, model.parameters.vis_range)\n        coh_force = Vec(0.0,0,0) \n        sep_force = Vec(0.0,0,0) \n        aln_force = Vec(0.0,0,0)\n        num = 0\n        for nbr in nbrs\n            num+=1\n            vec = nbr.pos - boid.pos\n            coh_force += vec\n            if norm(vec)< model.parameters.min_dis\n                sep_force -= vec\n            end\n            aln_force += nbr.vel\n        end\n        aln_force = num>0 ? (aln_force/ num - boid.vel)*model.parameters.aln_fac : aln_force\n        num = max(1, num)\n        coh_force *= (model.parameters.coh_fac/num)\n        sep_force *=  model.parameters.sep_fac\n        boid.vel  += (coh_force + sep_force) + aln_force\n        boid.vel  /= (norm(boid.vel)+ep)\n        boid.orientation = boid.vel\n        boid.pos += boid.vel*dt\n    end\nend\n\nrun_model!(model, steps=500, step_rule = step_rule!)","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"animate_sim(model)","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"(Image: png)","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[(:min_dis, :s, 0.01:0.1:1.0),\n        (:coh_fac, :s, 0.01:0.01:1.0),\n        (:sep_fac, :s, 0.01:0.01:1.0),\n        (:aln_fac, :s, 0.01:0.01:1.0),\n        (:vis_range, :s, 0.5:0.5:4.0)], frames=400) ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"(Image: png)","category":"page"},{"location":"boids3d/#Step-4:-Fetch-Data","page":"Flocking","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"It is easy to fetch any data recorded during simulation. For example, the data of average velocity of agents at each time step can be obtained as - ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"df = get_agents_avg_props(model, agent -> agent.vel, labels = [\"average velocity\"])","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"schelling3d/#Schelling-segregation-model","page":"Schellings Segregation model","title":"Schelling segregation model","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"using EasyABM","category":"page"},{"location":"schelling3d/#Step-1:-Create-Agents-and-Model","page":"Schellings Segregation model","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"Lets create 200 agents with properties pos, mood and color. The keeps_record_of argument is list of properties that the agent will record during time evolution. The min_alike property of the model which specifies the minimum number of alike neighbors for an agent to be happy, is set to be 8. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"@enum agentsfeeling happy sad\nagents = create_3d_agents(200, pos = (1,1,1), color = :red, mood = happy, keeps_record_of=[:pos, :mood])\nmodel = create_3d_model(agents, grid_size = (7,7,7), min_alike = 8, periodic = false)","category":"page"},{"location":"schelling3d/#Step-2:-Initialise-the-model","page":"Schellings Segregation model","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"In the second step we initialise the agents by defining initialiser! function and then sending it as an argument to init_model!. In the initialiser! function we randomly set agents color to be either :red or :green and set their positions randomly such that there is not more than one agent on each patch. Then we set the mood property of each agent to be happy or sad depending upon the number of alike agents in neighborhood. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"function initialise!(model)\n    for agent in model.agents\n        agent.color = [:red, :green][rand(1:2)]\n        x,y,z = random_empty_patch(model) \n        agent.pos = (x-0.5, y-0.5, z-0.5)     \n    end    \n    for agent in model.agents\n        nbrs = neighbors(agent, model, 1, metric = :grid)\n        num_same = 0\n        for nbr in nbrs\n            if nbr.color == agent.color\n                num_same += 1\n            end\n        end\n        if num_same < model.parameters.min_alike\n            agent.mood = sad\n        end\n    end\nend\ninit_model!(model, initialiser = initialise!)","category":"page"},{"location":"schelling3d/#Step-3:-Run-the-model","page":"Schellings Segregation model","title":"Step 3: Run the model","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"In this step we implement the step logic of the Schellings model in the step_rule! function and run the model for 200 steps. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"function step_rule!(model)\n    min_alike = model.parameters.min_alike\n    for agent in model.agents\n        num_alike = 0\n        for nbr in neighbors(agent, model,1)\n            if agent.color == nbr.color\n                num_alike += 1\n            end\n        end\n        if num_alike ≥ min_alike\n            agent.mood = happy\n        else\n            agent.mood = sad\n            x,y,z = random_empty_patch(model) \n            agent.pos = (x-0.5, y-0.5, z-0.5)\n        end\n    end\n    return\nend\n\nrun_model!(model, steps=200, step_rule = step_rule!)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"animate_sim(model)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"(Image: png)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"Once the model has been run it can be saved to the disk as a jld2 file using following function.","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"save_model(model, model_name = \"schelling3d_model\", save_as = \"schelling3d.jld2\", folder = \"/path/to/folder/\")","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"A model saved previously as jld2 file, can be fetched as follows ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"model = open_saved_model(model_name = \"schelling3d_model\", path = \"/path/to/folder/schelling3d.jld2\")","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"create_interactive_app(model, initialiser= initialise!,\n    step_rule=step_rule!,\n    model_controls=[(:min_alike, :s, 1:12)], \n    agent_plots=Dict(\"happy\"=> agent-> agent.mood == happy ? 1 : 0, \"sad\"=> agent-> agent.mood == sad ? 1 : 0),\n    frames=200)  \n","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"(Image: png)","category":"page"},{"location":"schelling3d/#Step-4:-Fetch-Data","page":"Schellings Segregation model","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"In this step we fetch data of number of happy and sad agents at each time step as a dataframe with following function. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"df = get_nums_agents(model, agent-> agent.mood == happy, agent-> agent.mood == sad,labels=[\"happy\",\"sad\"], plot_result=true)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"(Image: png)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"ising/#Ising-model","page":"Ising model","title":"Ising model","text":"","category":"section"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"We use Ising model as an example of using Graph Models in EasyABM. We will set up and run Ising model on a grid graph, however one can choose graph of any other  topology as well.","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"using EasyABM","category":"page"},{"location":"ising/#Step-1:-Create-Agents-and-Model","page":"Ising model","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"In this model we will work solely with the graph and won't reuire agents. We create a grid graph of size 20x20, an empty list of agents, and then create our graph model as follows. ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"graph = square_grid(20,20); # We could also use graphs generated with Graphs.jl package. \nagents = create_graph_agents(0);\nmodel = create_graph_model(agents, graph, temp = 0.1, coupl = 1.0)","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"The model has two parameters temperature temp and coupling coupl. ","category":"page"},{"location":"ising/#Step-2:-Initialise-the-model","page":"Ising model","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"In the second step we initialise the nodes of the graph through initialiser! function and then sending it as an argument to init_model!. In the initialiser! function we randomly set each node's color to either :black or :white and set their spin values to +1 for :black nodes and -1 for :white nodes. In the init_model! function the argument props_to_record specifies the nodes properties which we want to record during model run. ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"function initialiser!(model)\n    for node in model.graph.nodes\n        if rand()<0.5\n            model.graph.nodesprops[node].spin = 1\n            model.graph.nodesprops[node].color = :black\n        else\n            model.graph.nodesprops[node].spin = -1\n            model.graph.nodesprops[node].color = :white\n        end\n    end\nend\n\ninit_model!(model, initialiser = initialiser!, props_to_record = Dict(\"nodes\"=>[:color, :spin]))","category":"page"},{"location":"ising/#Step-3:-Run-the-model","page":"Ising model","title":"Step 3: Run the model","text":"","category":"section"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"In this step we implement the step logic of the Ising model in the step_rule! function and run the model for 200 steps. At each step of the simulation we take  100 Monte Carlo steps, where in each Monte Carlo step a node is selected at random and its spin and color values are flipped is the Ising energy condition is satisfied. ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"const nn = num_nodes(model) \n\nfunction step_rule!(model)\n    for i in 1:100\n        random_node = rand(1:nn)\n        spin = model.graph.nodesprops[random_node].spin\n        nbr_nodes = neighbor_nodes(random_node, model)\n        de = 0.0\n        for node in nbr_nodes\n            nbr_spin = model.graph.nodesprops[node].spin\n            de += spin*nbr_spin\n        end\n        de = 2*model.parameters.coupl * de\n        if (de < 0) || (rand() < exp(-de/model.parameters.temp))\n            model.graph.nodesprops[random_node].spin = - spin\n            model.graph.nodesprops[random_node].color = spin == -1 ? :black : :white\n        end\n    end\nend\n\nrun_model!(model, steps=200, step_rule = step_rule! )","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"animate_sim(model)","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"(Image: png)","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"Note that the scale slider is for changing the size of agents. As we have zero agents in the current model, this slider won't do anything. ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"Once the model has been run it can be saved to the disk as a jld2 file using following function.","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"save_model(model, model_name = \"ising_model\", save_as = \"ising.jld2\", folder = \"/path/to/folder/\")","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"A model saved previously as jld2 file, can be fetched as follows ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"model = open_saved_model(model_name = \"ising_model\", path = \"/path/to/folder/ising.jld2\")","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"create_interactive_app(model, initialiser= initialiser!,\n    props_to_record = Dict(\"nodes\"=>[:color, :spin]),\n    step_rule= step_rule!,\n    model_controls=[(:temp, :s, 0.05:0.05:5), (:coupl, :s, 0.01:0.1:5)],\n    node_plots = Dict(\"magnetisation\"=> x -> x.spin),\n    frames=200) ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"(Image: png)","category":"page"},{"location":"ising/#Step-4:-Fetch-Data","page":"Ising model","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"In this step we fetch the data of average spin of nodes (also called magnetisation) and plot the result as follows. ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"df = get_nodes_avg_props(model, node -> node.spin, labels=[\"magnetisation\"], plot_result = true)","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"(Image: png)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = EasyABM","category":"page"},{"location":"#EasyABM.jl","page":"Introduction","title":"EasyABM.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"EasyABM is a performant and easy to use framework for agent-based modeling. ","category":"page"},{"location":"#Package-Features","page":"Introduction","title":"Package Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Intuitive 4 step approach for any agent based model - Create, Initialise, Run, Fetch Data. \nSupport for Hetrogeneous agents, where each agent can record its own properties. \nGrid blocks, called patches, in 2d and 3d models can be assigned properties like agents.\nUnderlying Graph in a graph model can be chosen to be fully dynamic, in which edges and nodes can be added or removed or assigned properties like agents.\nEasy to create interactive animation in Jupyter notebook based on data collected during model run.\nLive interactive panel can also be easily created in Jupyter in a few lines of code. ","category":"page"},{"location":"conwaygol/#Conway's-Game-of-Life","page":"Conways Game of Life","title":"Conway's Game of Life","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"using EasyABM","category":"page"},{"location":"conwaygol/#Step-1:-Create-Agents-and-Model","page":"Conways Game of Life","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"We work with patches in this model, so we create our model with a list of zero agents. The size of the  grid in the model created is 20x20 and alive_percent is the fraction of patches that are live initially.","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"agents = create_2d_agents(0)\nmodel = create_2d_model(agents, grid_size = (20,20), alive_percent = 0.4)","category":"page"},{"location":"conwaygol/#Step-2:-Initialise-the-model","page":"Conways Game of Life","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"In the second step we initialise the agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we randomly set patches to be either of color :green or :white. The patches with green color have their  is_alive property set to true and the patches with white color have their is_alive property set to false. We specify the patch properties color and is_alive that we want to be recorded during time evolution in the props_to_record argument to the init_model! function.","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"function initialiser!(model)\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            if rand()<model.parameters.alive_percent\n                model.patches[i,j].color = :green\n                model.patches[i,j].is_alive = true\n            else\n                model.patches[i,j].color = :white\n                model.patches[i,j].is_alive = false\n            end\n        end\n    end\nend\n\ninit_model!(model, initialiser = initialiser!, \n    props_to_record=Dict(\"patches\"=>[:color, :is_alive]))","category":"page"},{"location":"conwaygol/#Step-3:-Run-the-model","page":"Conways Game of Life","title":"Step 3: Run the model","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"In this step we implement the step logic of the Conway's Game of Life model in the step_rule! function and run the model for 100 steps.  Since Conway's model requires all patches to be updated at the same time, in the step_rule! function we first compute the is_alive  property for all patches and then apply to patches.","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"function calculate_vals(model)\n    vals = [false for i in 1:model.size[1], j in 1:model.size[2]]\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            patch = model.patches[i,j]\n            nbrs = neighbor_patches((i,j), model, 1)\n            num_alive = 0\n            for nbr in nbrs\n                num_alive+= model.patches[nbr...].is_alive\n            end\n            condition1 = patch.is_alive && ((num_alive == 2) || (num_alive == 3))\n            condition2 = patch.is_alive && (num_alive == 3)\n            if condition1 || condition2\n                vals[i,j] = true\n            end\n        end\n    end\n    return vals\nend\n\nfunction apply_vals!(model, vals)\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            is_alive = vals[i,j]\n            model.patches[i,j].is_alive = is_alive\n            model.patches[i,j].color = is_alive ? :green : :white\n        end\n    end       \nend\n\n\nfunction step_rule!(model)\n    vals = calculate_vals(model)\n    apply_vals!(model, vals)\nend\n\nrun_model!(model, steps=100, step_rule = step_rule! )","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"animate_sim(model, show_grid=true)","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"(Image: png)","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"Once the model has been run it can be saved to the disk as a jld2 file using following function.","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"save_model(model, model_name = \"conways_gol_model\", save_as = \"conways_gol.jld2\", folder = \"/path/to/folder/\")","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"A model saved previously as jld2 file, can be fetched as follows ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"model = open_saved_model(model_name = \"conways_gol_model\", path = \"/path/to/folder/conways_gol.jld2\")","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[\n        (:alive_percent, :s, 0:0.01:1.0)\n        ], \n    frames=200, show_grid=true) ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"(Image: png)","category":"page"},{"location":"conwaygol/#Step-4:-Fetch-Data","page":"Conways Game of Life","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"We can fetch the data of number alive patches as follows. ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"df = get_nums_patches(model, patch-> patch.is_alive, labels=[\"Alive\"], \n    plot_result = true)","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"(Image: png)","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Studying an agents based model in EasyABM is basically a 4-step process. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create agents and model. (After creating the model one may also choose to explore the model through an interactive app.) \nInitialise the model, through an initialiser function.\nRun the model with a step_rule function.\nFetch and analyse data collected during model run. (Interactive visualisation based on the data collected during model run can also be easily created).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We explain these steps below through a very simple model of a star-planet system. Though it can be debated if a star-planet system can really qualify as an agent based model, it nevertheless serves as a good example for demonstrating the workings of EasyABM. ","category":"page"},{"location":"tutorial/#Step-1:-Create-the-agents-and-the-model.","page":"Tutorial","title":"Step 1: Create the agents and the model.","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the first step we create the agents and the model. For the star-planet system, we need one agent for the star and one for the planet. We will assume that the star is stationary and the planet revolves around it. We set the position of the star to be (5,5) which is the center point of the 2d space, as the default dimensions of 2d space in EasyABM is 10x10. We set the position of the planet to be (7,5) and its velocity to be (0,1). Since, the planet will change its position we require it to record its position and velocity during the model run. We specify this via keeps_record_of property of the planet. The gravity property of the model is a constant of proportionality for the force between the star and the planet. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"star = create_2d_agent( pos = (5,5), size = 15, color = :yellow) # by default 2d space is 10x10, so that (5,5) is center.\nplanet = create_2d_agent(pos = (7,5), vel = (0,1), size=5, color = :blue, keeps_record_of = [:pos, :vel]) \nmodel = create_2d_model([star, planet], gravity = 3.0)","category":"page"},{"location":"tutorial/#Step-2:-Initialise-the-model.","page":"Tutorial","title":"Step 2: Initialise the model.","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this step we define an initialiser function to set the initial properties of the agents. Suppose we want our planet to be at position (5,8) and velocity (-1, 0) initially. We can do so by defining an initialiser function and then sending it as an argument to init_model! function as follows.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function initialiser!(model)\n    planet = model.agents[2]\n    planet.pos = (5, 8)\n    planet.vel = (-1,0)\nend\n\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"tutorial/#Step-3:-Define-a-step_rule-and-run-the-model","page":"Tutorial","title":"Step 3: Define a step_rule and run the model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this step, we define rule for the time evolution and then run the model. We define our step_rule to be simply discretisation of Newton's equations for 2 body system.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function step_rule!(model)\n    gravity = model.parameters.gravity\n    star = model.agents[1]\n    planet = model.agents[2]\n    distance_vector = (star.pos - planet.pos)\n    distance = norm(distance_vector)\n    force = gravity*distance_vector/distance^3\n    planet.vel += force\n    planet.pos+= planet.vel  \nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can run the model for desired number of steps as follows","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"run_model!(model, steps = 200, step_rule = step_rule!)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once the model has run, we can look at the animation of the time evolutio with following line of code","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"animate_sim(model)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: png)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once the model has been run it can be saved to the disk as a jld2 file using following function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"save_model(model, model_name = \"sun_planet_model\", save_as = \"sun_planet.jld2\", folder = \"/path/to/folder/\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A model saved previously as jld2 file, can be fetched as follows ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"model = open_saved_model(model_name = \"sun_planet_model\", path = \"/path/to/folder/sun_planet.jld2\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Instead of first running the model, we can create an interactive app in Jupyter to explore the model by setting different valies of parameters, as shown below. Here, the model_control argument is for creating a slider with values from 1 to 5 in steps of 0.2 for the model parameter gravity. The agent_controls argument creates a slider for the x component of planet's initial velocity. The tail argument attaches a tail of length 30 with the planet by selecting it with its color property which we previously set to :blue. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[(:gravity, :s, 1:0.2:5.0)], \n    agent_controls=[(:vel, :s, [(x, 0.0) for x in -10.0:0.1:5])],\n    frames=200, tail = (30, agent -> agent.color == :blue)) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: png)","category":"page"},{"location":"tutorial/#Step-4:-Fetch-data","page":"Tutorial","title":"Step 4: Fetch data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this simple model, the only data we have collected is the position and velocity of the planet. We can get this data as follows. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df = get_agent_data(model.agents[2], model).record","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The following line of code returns the data of (half of the) speed of the planet during time evolution.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df = get_agents_avg_props(model, agent -> agent.color == :blue ? norm(agent.vel) : 0.0, labels = [\"Planet Speed/2\"], plot_result = true)   ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: png)","category":"page"}]
}
